import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';

// Supabase Ïó∞Í≤∞ ÌôïÏù∏
if (!supabase) {
  console.error('‚ùå Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®');
  throw new Error('Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÌôòÍ≤Ω Î≥ÄÏàòÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.');
}

// Ïä¨Î°Ø ÌòÑÌô© Ï°∞Ìöå
export async function GET(request: NextRequest) {
  try {
    console.log('üîÑ Ïä¨Î°Ø ÌòÑÌô© Ï°∞Ìöå Ï§ë...');

    const { searchParams } = new URL(request.url);
    const userGroup = searchParams.get('userGroup');
    const searchQuery = searchParams.get('search');
    const customerId = searchParams.get('customerId'); // ÌäπÏ†ï Í≥†Í∞ù ID ÌååÎùºÎØ∏ÌÑ∞
    const username = searchParams.get('username'); // Ïã§Ï†ú Í≥†Í∞ùÎ™Ö (customer_idÏôÄ Îß§Ïπ≠)
    const type = searchParams.get('type'); // 'slots' ÎòêÎäî 'slot_status' Íµ¨Î∂Ñ
    const skipSlotsTable = searchParams.get('skipSlotsTable'); // slots ÌÖåÏù¥Î∏î Ï°∞Ìöå Í±¥ÎÑàÎõ∞Í∏∞

    // type ÌååÎùºÎØ∏ÌÑ∞Ïóê Îî∞Îùº Îã§Î•∏ ÌÖåÏù¥Î∏î Ï°∞Ìöå
    if (type === 'slot_status') {
      // slot_status ÌÖåÏù¥Î∏î Ï°∞Ìöå (Ïø†Ìå° Ïï± Ï∂îÍ∞Ä ÌéòÏù¥ÏßÄÏö©)
      let slotStatusQuery = supabase
        .from('slot_status')
        .select('*')
        .order('created_at', { ascending: false });

      // Í∞úÎ≥Ñ Í≥†Í∞ù ÌïÑÌÑ∞ÎßÅ (customerIdÏôÄ usernameÏù¥ ÏûàÎäî Í≤ΩÏö∞)
      if (customerId && username) {
        slotStatusQuery = slotStatusQuery.eq('customer_id', username);
        console.log('üîç Í∞úÎ≥Ñ Í≥†Í∞ù Ïä¨Î°Ø ÌïÑÌÑ∞ÎßÅ:', { customerId, username });
      }

      const { data: slotStatusData, error: slotStatusError } = await slotStatusQuery;

      if (slotStatusError) {
        console.error('slot_status Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïò§Î•ò:', slotStatusError);
        return NextResponse.json(
          { error: 'Ïä¨Î°Ø Îì±Î°ù Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
          { status: 500 }
        );
      }

      // slots ÌÖåÏù¥Î∏îÏóêÏÑú ÎèôÏùºÌïú Í≥†Í∞ùÏùò Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (ÏûîÏó¨Í∏∞Í∞Ñ/Îì±Î°ùÏùº¬∑ÎßåÎ£åÏùº Í≥ÑÏÇ∞Ïö©)
      let slotsData = null;
      if (customerId && username && !skipSlotsTable) {
        try {
          console.log('üîç slots ÌÖåÏù¥Î∏î Ï°∞Ìöå ÏãúÏûë:', { customerId, username });
          const { data: slotsQueryData, error: slotsError } = await supabase
            .from('slots')
            .select('id, customer_id, customer_name, slot_type, slot_count, payment_type, payer_name, payment_amount, payment_date, usage_days, memo, status, created_at, updated_at, work_group, keyword, link_url, equipment_group')
            .eq('customer_id', username)
            .order('created_at', { ascending: false });

          if (slotsError) {
            console.error('‚ùå slots ÌÖåÏù¥Î∏î Ï°∞Ìöå Ïò§Î•ò:', slotsError);
            console.error('‚ùå Ïò§Î•ò ÏΩîÎìú:', slotsError.code);
            console.error('‚ùå Ïò§Î•ò Î©îÏãúÏßÄ:', slotsError.message);
            console.error('‚ùå Ïò§Î•ò ÏÑ∏Î∂ÄÏÇ¨Ìï≠:', slotsError.details);
            // slots ÌÖåÏù¥Î∏î Ï°∞Ìöå Ïã§Ìå®Ìï¥ÎèÑ Í≥ÑÏÜç ÏßÑÌñâ
            slotsData = [];
          } else {
            slotsData = slotsQueryData;
            console.log('‚úÖ slots ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÏôÑÎ£å:', slotsData?.length || 0, 'Í∞ú');
          }
        } catch (err) {
          console.error('‚ùå slots ÌÖåÏù¥Î∏î Ï°∞Ìöå ÏòàÏô∏:', err);
          // ÏòàÏô∏ Î∞úÏÉùÌï¥ÎèÑ Í≥ÑÏÜç ÏßÑÌñâ
          slotsData = [];
        }
      } else if (skipSlotsTable) {
        console.log('‚è≠Ô∏è slots ÌÖåÏù¥Î∏î Ï°∞Ìöå Í±¥ÎÑàÎõ∞Í∏∞ (skipSlotsTable=true)');
        slotsData = [];
      }

      // slot_status Îç∞Ïù¥ÌÑ∞Î•º Ïä¨Î°Ø Îì±Î°ù Î™©Î°ù ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò (ÏÇ¨Ïö©ÏûêÎ≥Ñ ÏàúÎ≤à 1Î≤àÎ∂ÄÌÑ∞ ÏãúÏûë)
      const formattedSlotStatusData = slotStatusData?.map((slot, index) => {
        // slots ÌÖåÏù¥Î∏îÏóêÏÑú ÎèôÏùºÌïú usage_daysÎ•º Í∞ÄÏßÑ Îç∞Ïù¥ÌÑ∞ Ï∞æÍ∏∞
        const matchingSlot = slotsData?.find((s: any) => s.usage_days === slot.usage_days);
        
        // slots ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ Í∑∏Í≤ÉÏùÑ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ slot_status Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
        const baseData = matchingSlot || slot;
        
        console.log('Ïä¨Î°Ø Îß§Ïπ≠ ÌôïÏù∏:', {
          slot_status_id: slot.id,
          slot_status_usage_days: slot.usage_days,
          slot_status_created_at: slot.created_at,
          matching_slot_found: !!matchingSlot,
          matching_slot_created_at: matchingSlot?.created_at,
          final_created_at: baseData.created_at,
          using_slots_data: !!matchingSlot
        });
        
        
        
        // ÎßåÎ£åÏùº Í∏∞Ï§Ä ÏûîÏó¨Í∏∞Í∞Ñ Í≥ÑÏÇ∞ (Ïùº, ÏãúÍ∞Ñ, Î∂Ñ Îã®ÏúÑ)
        const now = new Date();
        const createdDate = baseData.created_at ? new Date(baseData.created_at) : now;
        const usageDays = baseData.usage_days || 0;
        
        // ÎßåÎ£åÏùº Í≥ÑÏÇ∞ (created_at + usage_days) - DBÏùò updated_at ÎåÄÏã† ÏßÅÏ†ë Í≥ÑÏÇ∞
        const expiryDate = new Date(createdDate.getTime() + usageDays * 24 * 60 * 60 * 1000);
        
        // Ïã§Ï†ú ÏûîÏó¨ ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (Î∞ÄÎ¶¨Ï¥à)
        const remainingMs = Math.max(0, expiryDate.getTime() - now.getTime());
        
        // ÏûîÏó¨ ÏãúÍ∞ÑÏùÑ Ïùº, ÏãúÍ∞Ñ, Î∂ÑÏúºÎ°ú Î≥ÄÌôò
        const remainingDays = Math.floor(remainingMs / (24 * 60 * 60 * 1000));
        const remainingHours = Math.floor((remainingMs % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
        const remainingMinutes = Math.floor((remainingMs % (60 * 60 * 1000)) / (60 * 1000));
        
        // ÏûîÏó¨Í∏∞Í∞Ñ Î¨∏ÏûêÏó¥ ÏÉùÏÑ±
        let remainingTimeString = '';
        if (remainingDays > 0) {
          remainingTimeString += `${remainingDays}Ïùº`;
        }
        if (remainingHours > 0) {
          remainingTimeString += (remainingTimeString ? ' ' : '') + `${remainingHours}ÏãúÍ∞Ñ`;
        }
        if (remainingMinutes > 0) {
          remainingTimeString += (remainingTimeString ? ' ' : '') + `${remainingMinutes}Î∂Ñ`;
        }
        if (!remainingTimeString) {
          remainingTimeString = 'ÎßåÎ£åÎê®';
        }
        
        // Îì±Î°ùÏùºÍ≥º ÎßåÎ£åÏùº Í≥ÑÏÇ∞
        const formatDate = (date: Date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          const hours = String(date.getHours()).padStart(2, '0');
          const minutes = String(date.getMinutes()).padStart(2, '0');
          const seconds = String(date.getSeconds()).padStart(2, '0');
          return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        };
        
        const registrationDateRange = `${formatDate(createdDate)} ~ ${formatDate(expiryDate)}`;
        
        return {
          id: index + 1, // ÏàúÎ≤à (1Î∂ÄÌÑ∞ ÏãúÏûë)
          db_id: slot.id, // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ID (ÏÇ≠Ï†úÏö©)
          customer_id: slot.customer_id,
          customer_name: slot.customer_name,
          distributor: slot.distributor,
          work_group: slot.work_group,
          keyword: slot.keyword,
          link_url: slot.link_url,
          current_rank: slot.current_rank,
          start_rank: slot.start_rank,
          slot_count: slot.slot_count,
          traffic: slot.traffic,
          equipment_group: slot.equipment_group,
          remaining_days: remainingTimeString,
          registration_date: registrationDateRange,
          status: slot.status,
          memo: slot.memo,
          created_at: slot.created_at,
          usage_days: slot.usage_days
        };
      });

      return NextResponse.json({
        success: true,
        data: formattedSlotStatusData,
        slotsData: slotsData // slots ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞ÎèÑ Ìï®Íªò Î∞òÌôò
      });
    }

    // Í∏∞Î≥∏: slots ÌÖåÏù¥Î∏î Ï°∞Ìöå (Ïä¨Î°Ø ÌòÑÌô© ÌéòÏù¥ÏßÄÏö©)
    let slotsQuery = supabase
      .from('slots')
      .select('id, customer_id, customer_name, slot_type, slot_count, payment_type, payer_name, payment_amount, payment_date, usage_days, memo, status, created_at, updated_at, work_group, keyword, link_url, equipment_group')
      .order('created_at', { ascending: false });

    // ÌäπÏ†ï Í≥†Í∞ù ÌïÑÌÑ∞ÎßÅ (usernameÏúºÎ°ú ÌïÑÌÑ∞ÎßÅ)
    if (username) {
      slotsQuery = slotsQuery.eq('customer_id', username);
    }

    const { data: slotsData, error: slotsError } = await slotsQuery;

    if (slotsError) {
      console.error('slots Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïò§Î•ò:', slotsError);
      return NextResponse.json(
        { error: 'Ïä¨Î°Ø Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
        { status: 500 }
      );
    }

    // ÌäπÏ†ï Í≥†Í∞ù ÏöîÏ≤≠Ïù∏ Í≤ΩÏö∞ Ìï¥Îãπ Í≥†Í∞ùÏùò Ïä¨Î°Ø ÌòÑÌô©ÎèÑ Ï°∞Ìöå
    if (customerId && username) {
      console.log('üîç ÌäπÏ†ï Í≥†Í∞ù Ïä¨Î°Ø ÌòÑÌô© Ï°∞Ìöå:', { customerId, username });
      
      // Ìï¥Îãπ Í≥†Í∞ùÏùò Ïä¨Î°Ø ÌòÑÌô© (Ïù¥ÎØ∏ usernameÏúºÎ°ú ÌïÑÌÑ∞ÎßÅÎê®)
      const customerSlots = slotsData || [];
      console.log('üìä Í≥†Í∞ù Ïä¨Î°Ø ÌòÑÌô©:', customerSlots);

      // ÏÇ¨Ïö© Ï§ëÏù∏ Ïä¨Î°Ø Ïàò Í≥ÑÏÇ∞ (slot_status ÌÖåÏù¥Î∏îÏóêÏÑú)
      let usedSlots = 0;
      try {
        const { data: slotStatusData } = await supabase
          .from('slot_status')
          .select('slot_count')
          .eq('customer_id', username);
        
        usedSlots = slotStatusData?.reduce((sum, slot) => sum + (slot.slot_count || 0), 0) || 0;
      } catch (err) {
        console.log('slot_status Ï°∞Ìöå Ï§ë Ïò§Î•ò (Î¨¥Ïãú):', err);
      }

      // Ï¥ù Ïä¨Î°Ø Ïàò Í≥ÑÏÇ∞
      const totalSlots = customerSlots.reduce((sum, slot) => sum + (slot.slot_count || 0), 0);

      // Í≥†Í∞ù Ï†ïÎ≥¥ Ï°∞Ìöå (slots ÌÖåÏù¥Î∏îÏóêÏÑú customer_name Ïö∞ÏÑ† Ï°∞Ìöå)
      let customerName = '';
      let distributor = 'ÏùºÎ∞ò';
      
      // slots ÌÖåÏù¥Î∏îÏóêÏÑú customer_name Ï°∞Ìöå
      if (customerSlots && customerSlots.length > 0) {
        customerName = customerSlots[0].customer_name || '';
        distributor = customerSlots[0].work_group || 'ÏùºÎ∞ò';
      }
      
      // customer_nameÏù¥ ÏóÜÏúºÎ©¥ users ÌÖåÏù¥Î∏îÏóêÏÑú Ï°∞Ìöå
      if (!customerName) {
        try {
          const { data: userData } = await supabase
            .from('users')
            .select('name, distributor')
            .eq('username', username)
            .single();
          
          if (userData) {
            customerName = userData.name || '';
            distributor = userData.distributor || 'ÏùºÎ∞ò';
          }
        } catch (err) {
          console.log('users ÌÖåÏù¥Î∏î Ï°∞Ìöå Ï§ë Ïò§Î•ò (Î¨¥Ïãú):', err);
        }
      }

      return NextResponse.json({
        success: true,
        data: [{
          id: customerId,
          customerId: customerId,
          customerName: customerName,
          slotType: customerSlots[0]?.slot_type || 'Ïø†Ìå°',
          slotCount: totalSlots,
          usedSlots: usedSlots,
          remainingSlots: totalSlots - usedSlots,
          pausedSlots: 0,
          totalPaymentAmount: customerSlots.reduce((sum, slot) => sum + (slot.payment_amount || 0), 0),
          remainingDays: customerSlots[0]?.usage_days || 0,
          registrationDate: customerSlots[0]?.payment_date || '',
          expiryDate: customerSlots[0]?.payment_date || '',
          addDate: customerSlots[0]?.payment_date || '',
          status: customerSlots[0]?.status || 'active',
          userGroup: distributor
        }],
        stats: {
          totalSlots: totalSlots,
          usedSlots: usedSlots,
          remainingSlots: totalSlots - usedSlots,
          totalCustomers: 1
        }
      });
    }

    // Ï†ÑÏ≤¥ Ïä¨Î°Ø ÌòÑÌô© Ï°∞Ìöå
    const { data: slotStatusData } = await supabase
      .from('slot_status')
      .select('*')
      .eq('customer_id', username)
      .order('created_at', { ascending: false });
    
    const filteredData = slotsData?.map(slot => ({
      id: slot.id,
      customerId: slot.customer_id,
      customerName: '', // Î≥ÑÎèÑ Ï°∞Ìöå ÌïÑÏöî
      slotType: slot.slot_type || 'Ïø†Ìå°',
      slotCount: slot.slot_count || 1,
      usedSlots: 0, // Î≥ÑÎèÑ Í≥ÑÏÇ∞ ÌïÑÏöî
      remainingSlots: slot.slot_count || 1,
      pausedSlots: 0,
      totalPaymentAmount: slot.payment_amount || 0,
      remainingDays: slot.usage_days || 0,
      registrationDate: slot.payment_date || '',
      expiryDate: slot.payment_date || '',
      addDate: slot.payment_date || '',
      status: slot.status || 'active',
      userGroup: slot.work_group || 'ÏùºÎ∞ò'
    })) || [];

    // Í≤ÄÏÉâ ÌïÑÌÑ∞ÎßÅ
    if (searchQuery) {
      filteredData = filteredData.filter(slot =>
        slot.customerId.toLowerCase().includes(searchQuery.toLowerCase()) ||
        slot.customerName.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }

    return NextResponse.json({
      success: true,
      data: filteredData
    });

  } catch (error) {
    console.error('Ïä¨Î°Ø ÌòÑÌô© Ï°∞Ìöå API ÏòàÏô∏ Î∞úÏÉù:', error);
    return NextResponse.json(
      { error: 'ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
      { status: 500 }
    );
  }
}

// Ïä¨Î°Ø Îì±Î°ù (Í∞úÎ≥Ñ Ïä¨Î°Ø Ìï†Îãπ Î°úÏßÅ)
export async function POST(request: NextRequest) {
  try {
    console.log('üîÑ Í∞úÎ≥Ñ Ïä¨Î°Ø Ìï†Îãπ Ï≤òÎ¶¨ Ï§ë...');
    
    const body = await request.json();
    console.log('Î∞õÏùÄ Îç∞Ïù¥ÌÑ∞:', body);

    // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
    const requiredFields = ['customer_id', 'customer_name', 'keyword', 'link_url', 'slot_count'];
    for (const field of requiredFields) {
      if (!body[field]) {
        return NextResponse.json(
          { error: `ÌïÑÏàò ÌïÑÎìúÍ∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§: ${field}` },
          { status: 400 }
        );
      }
    }

    const customerId = body.customer_id;
    const requestedSlotCount = parseInt(body.slot_count) || 1;

    console.log(`üéØ Í≥†Í∞ù ${customerId}ÏóêÍ≤å ${requestedSlotCount}Í∞ú Ïä¨Î°Ø Ìï†Îãπ ÏöîÏ≤≠`);

    // 1. slots ÌÖåÏù¥Î∏îÏóêÏÑú Ìï¥Îãπ Í≥†Í∞ùÏùò ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïä¨Î°Ø Ï°∞Ìöå (usage_days ÎÇ¥Î¶ºÏ∞®Ïàú)
    const { data: availableSlots, error: slotsError } = await supabase
      .from('slots')
      .select('id, customer_id, customer_name, slot_type, slot_count, payment_type, payer_name, payment_amount, payment_date, usage_days, memo, status, created_at, updated_at, work_group, keyword, link_url, equipment_group')
      .eq('customer_id', customerId)
      .eq('status', 'active')
      .order('usage_days', { ascending: false }); // ÏûîÏó¨Í∏∞Í∞ÑÏù¥ Í∏¥ ÏàúÏÑúÎ°ú Ï†ïÎ†¨

    if (slotsError) {
      console.error('ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïä¨Î°Ø Ï°∞Ìöå Ïò§Î•ò:', slotsError);
      return NextResponse.json(
        { error: 'ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïä¨Î°ØÏùÑ Ï°∞ÌöåÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
        { status: 500 }
      );
    }

    if (!availableSlots || availableSlots.length === 0) {
      console.log('‚ùå Ìï†Îãπ Í∞ÄÎä•Ìïú Ïä¨Î°ØÏù¥ ÏóÜÏäµÎãàÎã§.');
      return NextResponse.json(
        { error: 'Ìï†Îãπ Í∞ÄÎä•Ìïú Ïä¨Î°ØÏù¥ ÏóÜÏäµÎãàÎã§.' },
        { status: 400 }
      );
    }

    console.log('üìä ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïä¨Î°Ø Î™©Î°ù:', availableSlots);

    // 1.5. ÌòÑÏû¨ ÏÇ¨Ïö© Ï§ëÏù∏ Ïä¨Î°Ø Ïàò ÌôïÏù∏
    const { data: currentSlotStatus } = await supabase
      .from('slot_status')
      .select('slot_count')
      .eq('customer_id', customerId);

    const currentUsedSlots = currentSlotStatus?.reduce((sum, slot) => sum + (slot.slot_count || 0), 0) || 0;
    const totalAvailableSlots = availableSlots.reduce((sum, slot) => sum + (slot.slot_count || 0), 0);
    const remainingAvailableSlots = totalAvailableSlots - currentUsedSlots;

    console.log('üìä Ïä¨Î°Ø ÌòÑÌô©:', {
      Ï¥ùÏÇ¨Ïö©Í∞ÄÎä•: totalAvailableSlots,
      ÌòÑÏû¨ÏÇ¨Ïö©Ï§ë: currentUsedSlots,
      ÎÇ®ÏùÄÏÇ¨Ïö©Í∞ÄÎä•: remainingAvailableSlots,
      ÏöîÏ≤≠Ïä¨Î°ØÏàò: requestedSlotCount
    });

    if (remainingAvailableSlots < requestedSlotCount) {
      return NextResponse.json(
        { error: `ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïä¨Î°ØÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§. (ÏÇ¨Ïö© Í∞ÄÎä•: ${remainingAvailableSlots}Í∞ú, ÏöîÏ≤≠: ${requestedSlotCount}Í∞ú)` },
        { status: 400 }
      );
    }

    // 2. slot_status ÌÖåÏù¥Î∏îÏóê Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
    const slotStatusEntries = [];
    
    // ÏöîÏ≤≠Îêú Ïä¨Î°Ø ÏàòÎßåÌÅº slot_status ÏóîÌä∏Î¶¨ ÏÉùÏÑ±
    for (let i = 0; i < requestedSlotCount; i++) {
      slotStatusEntries.push({
        customer_id: customerId,
        customer_name: body.customer_name,
        distributor: body.distributor || 'ÏùºÎ∞ò',
        work_group: body.work_group || 'Í≥µÌÜµ',
        keyword: body.keyword,
        link_url: body.link_url,
        current_rank: body.current_rank || '1 [0]',
        start_rank: body.start_rank || '1 [0]',
        slot_count: 1, // Í∞Å ÏóîÌä∏Î¶¨Îäî 1Í∞ú Ïä¨Î°Ø
        traffic: body.traffic || '0 (0/0)',
        equipment_group: body.equipment_group || 'ÏßÄÏ†ïÏïàÌï®',
        usage_days: body.usage_days || 30,
        status: body.status || 'ÏûëÎèôÏ§ë',
        memo: body.memo || '',
        slot_type: body.slot_type || 'Ïø†Ìå°'
      });
    }

    console.log('üìù slot_status ÌÖåÏù¥Î∏îÏóê ÏÇΩÏûÖÌï† Îç∞Ïù¥ÌÑ∞:', slotStatusEntries);

    const { data: insertedSlotStatus, error: insertError } = await supabase
      .from('slot_status')
      .insert(slotStatusEntries)
      .select();

    if (insertError) {
      console.error('slot_status ÏÇΩÏûÖ Ïò§Î•ò:', insertError);
      return NextResponse.json(
        { error: 'Ïä¨Î°Ø Îì±Î°ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
        { status: 500 }
      );
    }

    console.log('‚úÖ slot_status ÌÖåÏù¥Î∏î ÏÇΩÏûÖ ÏÑ±Í≥µ:', insertedSlotStatus);

    // 3. keywords ÌÖåÏù¥Î∏îÏóê ÌÇ§ÏõåÎìú Ï†ïÎ≥¥ Ï†ÄÏû• (Ï§ëÎ≥µ Ï≤¥ÌÅ¨)
    if (body.keyword) {
      try {
        const { data: existingKeyword } = await supabase
          .from('keywords')
          .select('id')
          .eq('keyword', body.keyword)
          .eq('slot_type', body.slot_type || 'Ïø†Ìå°')
          .single();

        if (!existingKeyword) {
          const { error: keywordError } = await supabase
            .from('keywords')
            .insert([{
              keyword: body.keyword,
              link_url: body.link_url,
              slot_type: body.slot_type || 'Ïø†Ìå°',
              slot_count: requestedSlotCount,
              current_rank: body.current_rank || '1 [0]',
              start_rank: body.start_rank || '1 [0]',
              traffic: body.traffic || '0 (0/0)',
              equipment_group: body.equipment_group || 'ÏßÄÏ†ïÏïàÌï®',
              usage_days: body.usage_days || 30,
              status: body.status || 'ÏûëÎèôÏ§ë',
              memo: body.memo || ''
            }]);

          if (keywordError) {
            console.error('keywords ÌÖåÏù¥Î∏î ÏÇΩÏûÖ Ïò§Î•ò:', keywordError);
            // keywords ÏÇΩÏûÖ Ïã§Ìå®Ìï¥ÎèÑ Ïä¨Î°Ø Îì±Î°ùÏùÄ ÏÑ±Í≥µÏúºÎ°ú Ï≤òÎ¶¨
          } else {
            console.log('‚úÖ keywords ÌÖåÏù¥Î∏î ÏÇΩÏûÖ ÏÑ±Í≥µ');
          }
        } else {
          console.log('‚ÑπÔ∏è ÌÇ§ÏõåÎìúÍ∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§:', body.keyword);
        }
      } catch (err) {
        console.error('keywords ÌÖåÏù¥Î∏î Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:', err);
        // keywords Ï≤òÎ¶¨ Ïã§Ìå®Ìï¥ÎèÑ Ïä¨Î°Ø Îì±Î°ùÏùÄ ÏÑ±Í≥µÏúºÎ°ú Ï≤òÎ¶¨
      }
    }

    return NextResponse.json({
      success: true,
      data: insertedSlotStatus,
      message: `${requestedSlotCount}Í∞ú Ïä¨Î°ØÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Îì±Î°ùÎêòÏóàÏäµÎãàÎã§.`
    });

  } catch (error) {
    console.error('Ïä¨Î°Ø Îì±Î°ù API ÏòàÏô∏ Î∞úÏÉù:', error);
    return NextResponse.json(
      { error: 'ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
      { status: 500 }
    );
  }
}